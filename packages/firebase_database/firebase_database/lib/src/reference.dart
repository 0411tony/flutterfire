// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of firebase_database;

/// A Reference represents a specific location in your Database and can be used
/// for reading or writing data to that Database location.
///
/// To get a reference, call the [ref] method on a [FirebaseDatabase] instance.
class Reference extends Query {
  final ReferencePlatform _delegate;

  Reference._(FirebaseDatabase database, this._delegate)
      : super._(database, _delegate);

  /// The last part of the Reference's path.
  ///
  /// For example, "ada" is the key for `https://<DATABASE_NAME>.firebaseio.com/users/ada`.
  ///
  /// The key of a root [Reference] is `null`.
  String /*?*/ get key {
    return _delegate.key;
  }

  /// The parent location of a [Reference].
  ///
  /// The parent of a root [Reference] is `null`.
  Reference /*?*/ get parent {
    ReferencePlatform parentReferencePlatform = _delegate.parent;

    if (parentReferencePlatform == null) {
      return null;
    }

    return Reference._(_database, parentReferencePlatform);
  }

  /// The root [Reference] of the Database.
  Reference /*!*/ get root {
    return Reference._(_database, _delegate.root);
  }

  /// Gets a [Reference] for the location at the specified relative path.
  ///
  /// The relative path can either be a simple child name (for example, "ada")
  /// or a deeper slash-separated path (for example, "ada/name/first").
  Reference child(String /*!*/ path) {
    return Reference._(_database, _delegate.child(path));
  }

  /// Returns an [OnDisconnect] instance for this [Reference].
  OnDisconnect onDisconnect() {
    return OnDisconnect._(_delegate.onDisconnect());
  }

  /// Generates a new [Reference] at the current path with a child node of a
  /// unique ID.
  ///
  /// The unique keys generated by push() are ordered by the current time,
  /// so the resulting list of items is chronologically sorted. The keys are
  /// also designed to be unguessable (they contain 72 random bits of entropy).
  Reference push() {
    return Reference._(_database, _delegate.push());
  }

  /// Removes the data at this Database location.
  ///
  /// Any data at child locations will also be deleted.
  Future<void> remove() {
    return _delegate.remove();
  }

  /// Writes data to this Database location.
  ///
  /// This will overwrite any data at this location and all child locations.
  ///
  /// Passing `null` for the new value is equivalent to calling [remove]; namely,
  /// all data at this location and all child locations will be deleted.
  ///
  /// [set] will remove any priority stored at this location, so if priority is
  /// meant to be preserved, you need to use [setWithPriority] instead.
  ///
  /// Note that modifying data with [set] will cancel any pending transactions
  /// at that location, so extreme care should be taken if mixing [set] and
  /// [transaction] to modify the same data.
  Future<void> set(dynamic value) {
    return _delegate.set(value);
  }

  /// Sets a priority for the data at this Database location.
  Future<void> setPriority(dynamic priority) {
    _assertPriority(priority);
    return _delegate.setPriority(priority);
  }

  /// Writes data the Database location. Like [set] but also specifies the priority for that data.
  Future<void> setWithPriority(dynamic value, dynamic priority) {
    _assertPriority(priority);
    return _delegate.setWithPriority(value, priority);
  }

  /// Atomically modifies the data at this location.
  ///
  /// Atomically modify the data at this location. Unlike a normal [set], which
  /// just overwrites the data regardless of its previous value, [transaction]
  /// is used to modify the existing value to a new value, ensuring there are no
  /// conflicts with other clients writing to the same location at the same time.
  ///
  /// To accomplish this, you pass [transaction] an update function which is used
  /// to transform the current value into a new value. If another client writes
  /// to the location before your new value is successfully written, your update
  /// function will be called again with the new current value, and the write
  /// will be retried. This will happen repeatedly until your write succeeds without
  /// conflict or you abort the transaction by not returning a value from your update function.
  ///
  /// Note: Modifying data with [set] will cancel any pending transactions at
  /// that location, so extreme care should be taken if mixing [set] and
  /// transaction to update the same data.
  ///
  /// Note: When using transactions with Security and Firebase Rules in place,
  /// be aware that a client needs `.read` access in addition to `.write` access
  /// in order to perform a transaction. This is because the client-side nature
  /// of transactions requires the client to read the data in order to
  /// transactionally update it.
  Future<DataSnapshot> transaction<T>(TransactionHandler<T> handler,
      {Duration timeout = const Duration(seconds: 5),
      bool applyLocally = true}) async {
    assert(timeout.inMilliseconds > 0);
    return DataSnapshot._(
        _database, await _delegate.transaction(handler, timeout, applyLocally));
  }

  /// Writes multiple values to the Database at once.
  ///
  /// The values argument contains multiple property-value pairs that will be
  /// written to the Database together. Each child property can either be a
  /// simple property (for example, "name") or a relative path (for example, "name/first")
  /// from the current location to the data to update.
  ///
  /// As opposed to the [set] method, [update] can be use to selectively update
  /// only the referenced properties at the current location (instead of replacing
  /// all the child properties at the current location).
  ///
  /// Note that modifying data with [update] will cancel any pending transactions
  /// at that location, so extreme care should be taken if mixing [update] and
  /// [transaction] to modify the same data.
  ///
  /// Passing `null` to [update] will remove the data at this location.
  // TODO(ehesp): If a value is passed, should it always be a Map?
  Future<void> update(dynamic value) {
    return _delegate.update(value);
  }
}
