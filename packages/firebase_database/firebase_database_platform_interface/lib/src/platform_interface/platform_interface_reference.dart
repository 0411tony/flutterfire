// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/*melos-nullsafety-remove-start*/
import 'dart:async';
/*melos-nullsafety-remove-end*/

import 'package:firebase_database_platform_interface/firebase_database_platform_interface.dart';

import 'package:firebase_database_platform_interface/src/internal/pointer.dart';

/// A [ReferencePlatform] can be used for querying nodes on the database and mutating
/// nodes.
///
/// Note: QueryPlatform extends PlatformInterface already.
abstract class ReferencePlatform extends QueryPlatform {
  /// Create instance of [DocumentReferencePlatform]
  ReferencePlatform(
    this.database,
    String /*?*/ path,
  )   : _pointer = Pointer(path),
        super(database, {});

  /// The Database instance associated with this document reference
  final FirebaseDatabasePlatform database;

  final Pointer _pointer;

  /// The full path to the Reference's path on the database.
  String /*!*/ get path {
    return _pointer.path;
  }

  /// The last part of the Reference's path.
  ///
  /// For example, "ada" is the key for `https://<DATABASE_NAME>.firebaseio.com/users/ada`.
  ///
  /// The key of a root [Reference] is `null`.
  String /*?*/ get key {
    return _pointer.key;
  }

  /// The parent location of a [Reference].
  ///
  /// The parent of a root [Reference] is `null`.
  ReferencePlatform /*?*/ get parent {
    throw UnimplementedError("parent is not implemented");
  }

  /// The root [Reference] of the Database.
  ReferencePlatform /*?*/ get root {
    throw UnimplementedError("root is not implemented");
  }

  /// Gets a [Reference] for the location at the specified relative path.
  ///
  /// The relative path can either be a simple child name (for example, "ada")
  /// or a deeper slash-separated path (for example, "ada/name/first").
  ReferencePlatform child(String /*!*/ path) {
    throw UnimplementedError("child is not implemented");
  }

  /// Returns an [OnDisconnect] instance for this [Reference].
  OnDisconnectPlatform onDisconnect() {
    throw UnimplementedError("onDisconnect() is not implemented");
  }

  /// Generates a new [Reference] at the current path with a child node of a
  /// unique ID.
  ///
  /// The unique keys generated by push() are ordered by the current time,
  /// so the resulting list of items is chronologically sorted. The keys are
  /// also designed to be unguessable (they contain 72 random bits of entropy).
  ReferencePlatform push() {
    throw UnimplementedError("push() is not implemented");
  }

  /// Removes the data at this Database location.
  ///
  /// Any data at child locations will also be deleted.
  Future<void> remove() {
    throw UnimplementedError("remove() is not implemented");
  }

  /// Writes data to this Database location.
  ///
  /// This will overwrite any data at this location and all child locations.
  ///
  /// Passing `null` for the new value is equivalent to calling [remove]; namely,
  /// all data at this location and all child locations will be deleted.
  ///
  /// [set] will remove any priority stored at this location, so if priority is
  /// meant to be preserved, you need to use [setWithPriority] instead.
  ///
  /// Note that modifying data with [set] will cancel any pending transactions
  /// at that location, so extreme care should be taken if mixing [set] and
  /// [transaction] to modify the same data.
  Future<void> set(dynamic value) {
    throw UnimplementedError("set() is not implemented");
  }

  /// Sets a priority for the data at this Database location.
  Future<void> setPriority(dynamic priority) {
    throw UnimplementedError("setPriority() is not implemented");
  }

  /// Writes data the Database location. Like [set] but also specifies the priority for that data.
  Future<void> setWithPriority(dynamic value, dynamic priority) {
    throw UnimplementedError("setWithPriority() is not implemented");
  }

  /// Atomically modifies the data at this location.
  ///
  /// Atomically modify the data at this location. Unlike a normal [set], which
  /// just overwrites the data regardless of its previous value, [transaction]
  /// is used to modify the existing value to a new value, ensuring there are no
  /// conflicts with other clients writing to the same location at the same time.
  ///
  /// To accomplish this, you pass [transaction] an update function which is used
  /// to transform the current value into a new value. If another client writes
  /// to the location before your new value is successfully written, your update
  /// function will be called again with the new current value, and the write
  /// will be retried. This will happen repeatedly until your write succeeds without
  /// conflict or you abort the transaction by not returning a value from your update function.
  ///
  /// Note: Modifying data with [set] will cancel any pending transactions at
  /// that location, so extreme care should be taken if mixing [set] and
  /// transaction to update the same data.
  ///
  /// Note: When using transactions with Security and Firebase Rules in place,
  /// be aware that a client needs `.read` access in addition to `.write` access
  /// in order to perform a transaction. This is because the client-side nature
  /// of transactions requires the client to read the data in order to
  /// transactionally update it.
  Future<DataSnapshotPlatform> transaction<T>(
      TransactionHandler<T> handler, Duration timeout, bool applyLocally) {
    throw UnimplementedError("transaction() is not implemented");
  }

  /// Writes multiple values to the Database at once.
  ///
  /// The values argument contains multiple property-value pairs that will be
  /// written to the Database together. Each child property can either be a
  /// simple property (for example, "name") or a relative path (for example, "name/first")
  /// from the current location to the data to update.
  ///
  /// As opposed to the [set] method, [update] can be use to selectively update
  /// only the referenced properties at the current location (instead of replacing
  /// all the child properties at the current location).
  ///
  /// Note that modifying data with [update] will cancel any pending transactions
  /// at that location, so extreme care should be taken if mixing [update] and
  /// [transaction] to modify the same data.
  ///
  /// Passing `null` to [update] will remove the data at this location.
  Future<void> update(dynamic value) {
    throw UnimplementedError("set() is not implemented");
  }
}
