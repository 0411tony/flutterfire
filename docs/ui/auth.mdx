---
title: Authentication UI
sidebar_label: Authentication
---

FlutterFire UI for Auth provides a simple and easy way to implement authentication in your Flutter app.
The library provides fully featured UI screens to drop into new or existing applications, along with
lower level implementation details for developers looking tigher control.

## Getting started

To get started with Firebase UI for Auth, you first need to ensure the `firebase_auth` plugin is
[installed on you project](https://firebase.flutter.dev/docs/auth/overview#installation).

The UI package provides various widgets and utilities to help you implement authentication in your
application. Widgets provide different layers of abstraction, such as fully styled sign-in screens
to underlying controllers enabling you to build your own UI expierience. The terminology used for these
abstractions is:

- **Screen**: A fully function, pre-styled and customizable widget which offers a complete authentication expereince (such as Sign In, Register, Profile Screen).
- **View**: A fully controlled widget which offers authentication functionality (such as Sign In), however if minimally styled allowing you to build your own UI around the view.
- **Widget**: A barebones widget which renders basic elements of a authentication flow, such as text inputs, buttons, etc.
- **Controller**: The lowest level of abtraction which provides no UI, however provides authentication controls (such as signing in, triggering OAuth flows, etc).

Internally the UI package builds upon these abstractions layers. For example a `SignInScreen` implements multiple `View`s, where a `View` implements and provides basic styling of multiple `Widget`s,
with the `Widget`s implementing a `Controller`.

## Adding a Screen

As mentioned, a Screen is a fully function, pre-styled and customizable widget which offers a complete authentication
expereince (such as Sign In, Register, Profile Screen). Screens are designed to be dropped into your application as a full
screen experience.

By design, a Screen does not depend on any implementation detail such as routing. Instead, a Screen can be directly returned
from a Widget, or from a page builder - it's up to you.

For this example, we'll be using the `SignInScreen` widget, which is a fully styled sign-in screen. We can ensure application users
are signed-in to our application by using the the `authStateChanges` stream from the `FirebaseAuth` service. If the user is not signed-in,
we will directly render the `SignInScreen` widget:

```dart
class MyApplication extends StatlessWidget {
  const MyApplication({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<User?>(
      stream: FirebaseAuth.instance.userChanges(),
      builder: (context, snapshot) {
        // User is not signed in!
        if (!snapshot.hasData) {
          return SignInScreen(
            providerConfigs: [
              // ... TODO!
            ],
          );
        }

        // ...
      },
      }
    );
  }
}
```

The `SignInScreen` widget requires at a minimum a list of `ProviderConfiguration` instances are provided,
which detail the expected authentication providers a user can use to sign in with (for example, Email, Google, Facebook, etc).

By adding a new provider to the list, the UI library will render the appropriate UI in the order specified:

```dart
return SignInScreen(
  providerConfigs: [
    EmailProviderConfiguration(),
    GoogleProviderConfiguration(clientId: '...'),
  ],
);
```

> To learn more about providers, read the [providers](#providers) documentation.

Such providers will render the UI with a sign-in form for email & password sign in, along with a sign-in button for Google:

TODO screenshot

Although usable, you may be looking for some more flare to your UI. The `SignInScreen` widget allows you to customize the screen
to easily provide your own UI elements, such as a logo. The widget provides a `headerBuilder` property allowing you to provide
such functionality.

For example, to add a logo which appears at the top of the screen:

```dart
return SignInScreen(
  providerConfigs: [
    // ...
  ],
  headerBuilder: (context, constraints, _) {
    return Padding(
      padding: const EdgeInsets.all(20),
      child: AspectRatio(
        aspectRatio: 1,
        child: SvgPicture.asset('assets/images/logo.svg'),
      ),
    );
  },
);
```

TODO screenshot

Futhermore, for Desktop / wider screens the widget enables you to provide a side-builder, which renders
to the side of the main authentication functionality further enhancing the UI:

```dart
return SignInScreen(
  providerConfigs: [
    // ...
  ],
  headerBuilder: (context, constraints, _) {
    // ...
  },
  sideBuilder: (context, constraints) {
    return Center(
      child: Padding(
        padding: EdgeInsets.all(constraints.maxWidth / 8),
        child: SvgPicture.asset(
          'assets/images/sign_in_background.svg',
          width: constraints.maxWidth / 2,
          height: constraints.maxWidth / 2,
        ),
      ),
    );
  },
);
```

## Specifying a `FirebaseApp`

By default, all functionality from the UI will use the default `FirebaseApp` instance. If you wish to use a
different instance, provide this a the `auth` parameter:

```dart
return SignInScreen(
  auth: Firebase.app('secondary-app'),
  //...
```

## Lower level abstractions

In some cases, the pre-build Screens provided by the package may not be sufficient. For example you may already
have an agreed style guide which the screens do not satisfy.

### Views & Widgets

The UI package exposes widgets which control the authentication implementation logic, however can be dropped in to
your own application flows.

For example, you may wish to allow users to sign-in with an email and password - you've already built your application
UI however still want to allow the UI package to handle the sign-in process. In this scenario, you can integrate the 
`EmailForm` widget into an existing UI! The `EmailForm` widget renders a basic email sign in form (email & password 
text inputs) along with a submit button.

Go ahead a add the `EmailForm` widget to your application:

```dart
class MySignInScreen extends StatlessWidget {
  const MySignInScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return EmailForm();
  }
}
```

As you can see, the `EmailForm` widget interally handles the authentication logic, however is largely unstyled - only 
basic element padding is provided. By design it is not constrained allowing you to easily provide your own UI 
around it:

```dart
@override
Widget build(BuildContext context) {
  // TODO example of a UI wrapping the EmailForm
}
```

TODO screenshot

### Controllers

Futhermore, if the individual widgets are not sufficient, you may wish to provide your own implementation of the
entire UI flow using controllers.

TODO docs on building custom implementations

## Providers

TODO list / docs on providers